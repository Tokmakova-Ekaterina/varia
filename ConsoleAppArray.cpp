
// TokmakovaEkaterina09.10.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
using namespace std;
void excl(int*&, int&, int);


int main()
{
    int arr1[]{ 3, 10, 11, 18, 45, 6, 9 };
    int arr2[]{ 10, 45, 34, 86, 78 };            // объявиление массивов
    int size1 = sizeof(arr1) / sizeof(arr1[0]);
    int size2 = sizeof(arr2) / sizeof(arr2[0]);  // нахождение количества элементов в массиве
    int size3 = 0;

    setlocale(0, "");
    // cout << "Hello World!\n";
     cout << "\n\tФункция формирует массив без повторяющихся чисел из двух данных массивов:\n"
          << "\n\t{ 3, 10, 11, 18, 45, 6, 9 },\n"
          << "\n\t{ 10, 45, 34, 86, 78 }\n";
    int* p;                                       // объявляем указатель
    p = arr1;                                       // указатель указывает на массив, на нулевой элемент
    int v, i;                               //     объявляем переменные: значение элемента и счетчик цикла
    int* arr3 = new int[size3];   // объявление указателя на динамический массив, имеющим размер size3
    //  на размер одного элемента

    for (i = 0; i < size1; i++)                  // цикл по первому массиву
    {
        v = *p;                               //   присваиваем переменной значение указателя

        int flag = 1;                 // объявляем флаг, показывающий есть ли совпадения в другом массиве

        for (int j = 0; j < size2; j++)           // цикл по элементам второго массива
        {
            if (arr1[i] == arr2[j])   // сравнение элементов, если значения равны 
            {
                flag = 0;     // флагу присваиваем значение ноль
                break;                 // прерываем цикл проверки
            }
        }
        if (flag == 1)                  // если совпадений нет  

            excl(arr3, size3, v);       // вызываем метод excl

        p++;                             // переходим к следующему элементу
    }

    p = arr2;                      // указатель направляется на массив arr2   

    for (i = 0; i < size2; i++)          // проход по элементам второго массива
    {
        v = *p;                   //   присваиваем переменной значение указателя


        int flag = 1;    // объявляем флаг, показывающий есть ли совпадения в другом массиве

        for (int j = 0; j < size1; j++)   // цикл по элементам второго массива
        {
            if (arr2[i] == arr1[j])      //сравнение элементов, если значения равны флагу присваиваем ноль   
            {
                flag = 0;     // флагу присваиваем значение ноль
                break;        // прерываем цикл проверки
            }
        }
        if (flag == 1)        // если совпадений нет 

            excl(arr3, size3, v);    // вызываем метод excl

        p++;    // переходим к следующему элементу
    }

    delete[] arr3;          // удаляем динамический массив

    return 0;              // завершение программы
}

void excl(int*& arr3, int& size3, int v) //описание метода: принимает параметром указатель на ссылку на массив
{
    int* newArray = new int[size3 + 1]; //объявляем указатель на динамический массив, увеличение памяти 
    //  на размер одного элемента
     cout << "\n\t";
    for (int i = 0; i < size3; i++)            //  цикл по массиву arr3 
    {
        newArray[i] = arr3[i];         //     копируем элементы в новый увеличенный массив
    }
    newArray[size3] = v;                //  присваиваем значение в конец массива
   
    for (int i = 0; i <= size3; i++)     //  в цикле вывод на экран элементов массива

        cout << newArray[i] << " ";

    delete[] arr3;                   // удаление массива, на который указывал указатель arr3

    arr3 = newArray;            //  устанавливаем указатель arr3 на массив newArray

}
















// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
